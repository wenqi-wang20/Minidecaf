Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program function
Rule 3     program -> function
Rule 4     program -> program declaration Semi
Rule 5     program -> declaration Semi
Rule 6     type -> Int
Rule 7     function -> type Identifier LParen parameter_list RParen LBrace block RBrace
Rule 8     function -> type Identifier LParen parameter_list RParen Semi
Rule 9     block -> block block_item
Rule 10    block -> empty
Rule 11    block_item -> statement
Rule 12    block_item -> declaration Semi
Rule 13    statement -> statement_matched
Rule 14    statement -> statement_unmatched
Rule 15    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 16    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 17    statement_unmatched -> If LParen expression RParen statement
Rule 18    statement_matched -> While LParen expression RParen statement_matched
Rule 19    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 20    statement_matched -> Return expression Semi
Rule 21    statement_matched -> opt_expression Semi
Rule 22    statement_matched -> LBrace block RBrace
Rule 23    statement_matched -> Break Semi
Rule 24    opt_expression -> expression
Rule 25    opt_expression -> empty
Rule 26    declaration -> type Identifier
Rule 27    declaration -> type Identifier Assign expression
Rule 28    expression -> assignment
Rule 29    assignment -> conditional
Rule 30    conditional -> logical_or
Rule 31    logical_or -> logical_and
Rule 32    logical_and -> bit_or
Rule 33    bit_or -> xor
Rule 34    xor -> bit_and
Rule 35    bit_and -> equality
Rule 36    equality -> relational
Rule 37    relational -> additive
Rule 38    additive -> multiplicative
Rule 39    multiplicative -> unary
Rule 40    unary -> postfix
Rule 41    postfix -> primary
Rule 42    unary -> Minus unary
Rule 43    unary -> BitNot unary
Rule 44    unary -> Not unary
Rule 45    assignment -> unary Assign expression
Rule 46    logical_or -> logical_or Or logical_and
Rule 47    logical_and -> logical_and And bit_or
Rule 48    bit_or -> bit_or BitOr xor
Rule 49    xor -> xor Xor bit_and
Rule 50    bit_and -> bit_and BitAnd equality
Rule 51    equality -> equality NotEqual relational
Rule 52    equality -> equality Equal relational
Rule 53    relational -> relational Less additive
Rule 54    relational -> relational Greater additive
Rule 55    relational -> relational LessEqual additive
Rule 56    relational -> relational GreaterEqual additive
Rule 57    additive -> additive Plus multiplicative
Rule 58    additive -> additive Minus multiplicative
Rule 59    multiplicative -> multiplicative Mul unary
Rule 60    multiplicative -> multiplicative Div unary
Rule 61    multiplicative -> multiplicative Mod unary
Rule 62    conditional -> logical_or Question expression Colon conditional
Rule 63    primary -> Integer
Rule 64    primary -> Identifier
Rule 65    primary -> LParen expression RParen
Rule 66    statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
Rule 67    statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 68    statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
Rule 69    statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 70    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 71    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 72    statement_matched -> Continue Semi
Rule 73    parameter -> parameter_item
Rule 74    parameter -> parameter_arr_single
Rule 75    parameter -> parameter_arr_multi
Rule 76    parameter_arr_single -> parameter_item LBracket empty RBracket
Rule 77    parameter_arr_single -> parameter_item LBracket Integer RBracket
Rule 78    parameter_arr_multi -> parameter_arr_single LBracket Integer RBracket
Rule 79    parameter_item -> type Identifier
Rule 80    parameter_list -> parameter_list Comma parameter
Rule 81    parameter_list -> parameter
Rule 82    parameter_list -> empty
Rule 83    expression_list -> expression_list Comma expression
Rule 84    expression_list -> expression
Rule 85    expression_list -> empty
Rule 86    postfix -> Identifier LParen expression_list RParen
Rule 87    postfix -> multidim_arr
Rule 88    postfix -> singledim_arr
Rule 89    singledim_arr -> Identifier LBracket expression RBracket
Rule 90    multidim_arr -> singledim_arr LBracket expression RBracket
Rule 91    multidim_arr -> multidim_arr LBracket expression RBracket
Rule 92    declaration -> multidim_decl
Rule 93    declaration -> singledim_decl
Rule 94    singledim_decl -> type Identifier LBracket Integer RBracket
Rule 95    multidim_decl -> singledim_decl LBracket Integer RBracket
Rule 96    multidim_decl -> multidim_decl LBracket Integer RBracket
Rule 97    intlist -> empty
Rule 98    intlist -> Integer
Rule 99    intlist -> intlist Comma Integer
Rule 100   declaration -> multidim_decl Assign LBrace intlist RBrace
Rule 101   declaration -> singledim_decl Assign LBrace intlist RBrace

Terminals, with rules where they appear

And                  : 47
Assign               : 27 45 100 101
BitAnd               : 50
BitNot               : 43
BitOr                : 48
Break                : 23
Colon                : 62
Comma                : 80 83 99
Continue             : 72
Div                  : 60
Do                   : 70 71
Else                 : 15 16
Equal                : 52
For                  : 66 67 68 69
Greater              : 54
GreaterEqual         : 56
Identifier           : 7 8 26 27 64 79 86 89 94
If                   : 15 16 17
Int                  : 6
Integer              : 63 77 78 94 95 96 98 99
LBrace               : 7 22 100 101
LBracket             : 76 77 78 89 90 91 94 95 96
LParen               : 7 8 15 16 17 18 19 65 66 67 68 69 70 71 86
Less                 : 53
LessEqual            : 55
Minus                : 42 58
Mod                  : 61
Mul                  : 59
Not                  : 44
NotEqual             : 51
Or                   : 46
Plus                 : 57
Question             : 62
RBrace               : 7 22 100 101
RBracket             : 76 77 78 89 90 91 94 95 96
RParen               : 7 8 15 16 17 18 19 65 66 67 68 69 70 71 86
Return               : 20
Semi                 : 4 5 8 12 20 21 23 66 66 67 67 68 68 69 69 70 71 72
While                : 18 19 70 71
Xor                  : 49
error                : 

Nonterminals, with rules where they appear

additive             : 37 53 54 55 56 57 58
assignment           : 28
bit_and              : 34 49 50
bit_or               : 32 47 48
block                : 7 9 22
block_item           : 9
conditional          : 29 62
declaration          : 4 5 12 68 69
empty                : 10 25 76 82 85 97
equality             : 35 50 51 52
expression           : 15 16 17 18 19 20 24 27 45 62 65 70 71 83 84 89 90 91
expression_list      : 83 86
function             : 2 3
intlist              : 99 100 101
logical_and          : 31 46 47
logical_or           : 30 46 62
multidim_arr         : 87 91
multidim_decl        : 92 96 100
multiplicative       : 38 57 58 59 60 61
opt_expression       : 21 66 66 66 67 67 67 68 68 69 69
parameter            : 80 81
parameter_arr_multi  : 75
parameter_arr_single : 74 78
parameter_item       : 73 76 77
parameter_list       : 7 8 80
postfix              : 40
primary              : 41
program              : 2 4 0
relational           : 36 51 52 53 54 55 56
singledim_arr        : 88 90
singledim_decl       : 93 95 101
statement            : 11 17
statement_matched    : 13 15 15 16 18 66 68 70
statement_unmatched  : 14 16 19 67 69 71
type                 : 7 8 26 27 79 94
unary                : 39 42 43 44 45 59 60 61
xor                  : 33 48 49

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program function
    (3) program -> . function
    (4) program -> . program declaration Semi
    (5) program -> . declaration Semi
    (7) function -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> . type Identifier LParen parameter_list RParen Semi
    (26) declaration -> . type Identifier
    (27) declaration -> . type Identifier Assign expression
    (92) declaration -> . multidim_decl
    (93) declaration -> . singledim_decl
    (100) declaration -> . multidim_decl Assign LBrace intlist RBrace
    (101) declaration -> . singledim_decl Assign LBrace intlist RBrace
    (6) type -> . Int
    (95) multidim_decl -> . singledim_decl LBracket Integer RBracket
    (96) multidim_decl -> . multidim_decl LBracket Integer RBracket
    (94) singledim_decl -> . type Identifier LBracket Integer RBracket

    Int             shift and go to state 7

    program                        shift and go to state 1
    function                       shift and go to state 2
    declaration                    shift and go to state 3
    type                           shift and go to state 4
    multidim_decl                  shift and go to state 5
    singledim_decl                 shift and go to state 6

state 1

    (0) S' -> program .
    (2) program -> program . function
    (4) program -> program . declaration Semi
    (7) function -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> . type Identifier LParen parameter_list RParen Semi
    (26) declaration -> . type Identifier
    (27) declaration -> . type Identifier Assign expression
    (92) declaration -> . multidim_decl
    (93) declaration -> . singledim_decl
    (100) declaration -> . multidim_decl Assign LBrace intlist RBrace
    (101) declaration -> . singledim_decl Assign LBrace intlist RBrace
    (6) type -> . Int
    (95) multidim_decl -> . singledim_decl LBracket Integer RBracket
    (96) multidim_decl -> . multidim_decl LBracket Integer RBracket
    (94) singledim_decl -> . type Identifier LBracket Integer RBracket

    Int             shift and go to state 7

    function                       shift and go to state 8
    declaration                    shift and go to state 9
    type                           shift and go to state 4
    multidim_decl                  shift and go to state 5
    singledim_decl                 shift and go to state 6

state 2

    (3) program -> function .

    Int             reduce using rule 3 (program -> function .)
    $end            reduce using rule 3 (program -> function .)


state 3

    (5) program -> declaration . Semi

    Semi            shift and go to state 10


state 4

    (7) function -> type . Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> type . Identifier LParen parameter_list RParen Semi
    (26) declaration -> type . Identifier
    (27) declaration -> type . Identifier Assign expression
    (94) singledim_decl -> type . Identifier LBracket Integer RBracket

    Identifier      shift and go to state 11


state 5

    (92) declaration -> multidim_decl .
    (100) declaration -> multidim_decl . Assign LBrace intlist RBrace
    (96) multidim_decl -> multidim_decl . LBracket Integer RBracket

    Semi            reduce using rule 92 (declaration -> multidim_decl .)
    Assign          shift and go to state 12
    LBracket        shift and go to state 13


state 6

    (93) declaration -> singledim_decl .
    (101) declaration -> singledim_decl . Assign LBrace intlist RBrace
    (95) multidim_decl -> singledim_decl . LBracket Integer RBracket

    Semi            reduce using rule 93 (declaration -> singledim_decl .)
    Assign          shift and go to state 14
    LBracket        shift and go to state 15


state 7

    (6) type -> Int .

    Identifier      reduce using rule 6 (type -> Int .)


state 8

    (2) program -> program function .

    Int             reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 9

    (4) program -> program declaration . Semi

    Semi            shift and go to state 16


state 10

    (5) program -> declaration Semi .

    Int             reduce using rule 5 (program -> declaration Semi .)
    $end            reduce using rule 5 (program -> declaration Semi .)


state 11

    (7) function -> type Identifier . LParen parameter_list RParen LBrace block RBrace
    (8) function -> type Identifier . LParen parameter_list RParen Semi
    (26) declaration -> type Identifier .
    (27) declaration -> type Identifier . Assign expression
    (94) singledim_decl -> type Identifier . LBracket Integer RBracket

    LParen          shift and go to state 17
    Semi            reduce using rule 26 (declaration -> type Identifier .)
    Assign          shift and go to state 18
    LBracket        shift and go to state 19


state 12

    (100) declaration -> multidim_decl Assign . LBrace intlist RBrace

    LBrace          shift and go to state 20


state 13

    (96) multidim_decl -> multidim_decl LBracket . Integer RBracket

    Integer         shift and go to state 21


state 14

    (101) declaration -> singledim_decl Assign . LBrace intlist RBrace

    LBrace          shift and go to state 22


state 15

    (95) multidim_decl -> singledim_decl LBracket . Integer RBracket

    Integer         shift and go to state 23


state 16

    (4) program -> program declaration Semi .

    Int             reduce using rule 4 (program -> program declaration Semi .)
    $end            reduce using rule 4 (program -> program declaration Semi .)


state 17

    (7) function -> type Identifier LParen . parameter_list RParen LBrace block RBrace
    (8) function -> type Identifier LParen . parameter_list RParen Semi
    (80) parameter_list -> . parameter_list Comma parameter
    (81) parameter_list -> . parameter
    (82) parameter_list -> . empty
    (73) parameter -> . parameter_item
    (74) parameter -> . parameter_arr_single
    (75) parameter -> . parameter_arr_multi
    (1) empty -> .
    (79) parameter_item -> . type Identifier
    (76) parameter_arr_single -> . parameter_item LBracket empty RBracket
    (77) parameter_arr_single -> . parameter_item LBracket Integer RBracket
    (78) parameter_arr_multi -> . parameter_arr_single LBracket Integer RBracket
    (6) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    type                           shift and go to state 24
    parameter_list                 shift and go to state 25
    parameter                      shift and go to state 26
    empty                          shift and go to state 27
    parameter_item                 shift and go to state 28
    parameter_arr_single           shift and go to state 29
    parameter_arr_multi            shift and go to state 30

state 18

    (27) declaration -> type Identifier Assign . expression
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 32
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 19

    (94) singledim_decl -> type Identifier LBracket . Integer RBracket

    Integer         shift and go to state 54


state 20

    (100) declaration -> multidim_decl Assign LBrace . intlist RBrace
    (97) intlist -> . empty
    (98) intlist -> . Integer
    (99) intlist -> . intlist Comma Integer
    (1) empty -> .

    Integer         shift and go to state 57
    RBrace          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    intlist                        shift and go to state 55
    empty                          shift and go to state 56

state 21

    (96) multidim_decl -> multidim_decl LBracket Integer . RBracket

    RBracket        shift and go to state 58


state 22

    (101) declaration -> singledim_decl Assign LBrace . intlist RBrace
    (97) intlist -> . empty
    (98) intlist -> . Integer
    (99) intlist -> . intlist Comma Integer
    (1) empty -> .

    Integer         shift and go to state 57
    RBrace          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    intlist                        shift and go to state 59
    empty                          shift and go to state 56

state 23

    (95) multidim_decl -> singledim_decl LBracket Integer . RBracket

    RBracket        shift and go to state 60


state 24

    (79) parameter_item -> type . Identifier

    Identifier      shift and go to state 61


state 25

    (7) function -> type Identifier LParen parameter_list . RParen LBrace block RBrace
    (8) function -> type Identifier LParen parameter_list . RParen Semi
    (80) parameter_list -> parameter_list . Comma parameter

    RParen          shift and go to state 62
    Comma           shift and go to state 63


state 26

    (81) parameter_list -> parameter .

    RParen          reduce using rule 81 (parameter_list -> parameter .)
    Comma           reduce using rule 81 (parameter_list -> parameter .)


state 27

    (82) parameter_list -> empty .

    RParen          reduce using rule 82 (parameter_list -> empty .)
    Comma           reduce using rule 82 (parameter_list -> empty .)


state 28

    (73) parameter -> parameter_item .
    (76) parameter_arr_single -> parameter_item . LBracket empty RBracket
    (77) parameter_arr_single -> parameter_item . LBracket Integer RBracket

    RParen          reduce using rule 73 (parameter -> parameter_item .)
    Comma           reduce using rule 73 (parameter -> parameter_item .)
    LBracket        shift and go to state 64


state 29

    (74) parameter -> parameter_arr_single .
    (78) parameter_arr_multi -> parameter_arr_single . LBracket Integer RBracket

    RParen          reduce using rule 74 (parameter -> parameter_arr_single .)
    Comma           reduce using rule 74 (parameter -> parameter_arr_single .)
    LBracket        shift and go to state 65


state 30

    (75) parameter -> parameter_arr_multi .

    RParen          reduce using rule 75 (parameter -> parameter_arr_multi .)
    Comma           reduce using rule 75 (parameter -> parameter_arr_multi .)


state 31

    (86) postfix -> Identifier . LParen expression_list RParen
    (64) primary -> Identifier .
    (89) singledim_arr -> Identifier . LBracket expression RBracket

    LParen          shift and go to state 66
    Assign          reduce using rule 64 (primary -> Identifier .)
    Mul             reduce using rule 64 (primary -> Identifier .)
    Div             reduce using rule 64 (primary -> Identifier .)
    Mod             reduce using rule 64 (primary -> Identifier .)
    Plus            reduce using rule 64 (primary -> Identifier .)
    Minus           reduce using rule 64 (primary -> Identifier .)
    Less            reduce using rule 64 (primary -> Identifier .)
    Greater         reduce using rule 64 (primary -> Identifier .)
    LessEqual       reduce using rule 64 (primary -> Identifier .)
    GreaterEqual    reduce using rule 64 (primary -> Identifier .)
    NotEqual        reduce using rule 64 (primary -> Identifier .)
    Equal           reduce using rule 64 (primary -> Identifier .)
    BitAnd          reduce using rule 64 (primary -> Identifier .)
    Xor             reduce using rule 64 (primary -> Identifier .)
    BitOr           reduce using rule 64 (primary -> Identifier .)
    And             reduce using rule 64 (primary -> Identifier .)
    Question        reduce using rule 64 (primary -> Identifier .)
    Or              reduce using rule 64 (primary -> Identifier .)
    Semi            reduce using rule 64 (primary -> Identifier .)
    RParen          reduce using rule 64 (primary -> Identifier .)
    Comma           reduce using rule 64 (primary -> Identifier .)
    RBracket        reduce using rule 64 (primary -> Identifier .)
    Colon           reduce using rule 64 (primary -> Identifier .)
    LBracket        shift and go to state 67


state 32

    (27) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 27 (declaration -> type Identifier Assign expression .)


state 33

    (28) expression -> assignment .

    Semi            reduce using rule 28 (expression -> assignment .)
    RParen          reduce using rule 28 (expression -> assignment .)
    Comma           reduce using rule 28 (expression -> assignment .)
    RBracket        reduce using rule 28 (expression -> assignment .)
    Colon           reduce using rule 28 (expression -> assignment .)


state 34

    (29) assignment -> conditional .

    Semi            reduce using rule 29 (assignment -> conditional .)
    RParen          reduce using rule 29 (assignment -> conditional .)
    Comma           reduce using rule 29 (assignment -> conditional .)
    RBracket        reduce using rule 29 (assignment -> conditional .)
    Colon           reduce using rule 29 (assignment -> conditional .)


state 35

    (45) assignment -> unary . Assign expression
    (39) multiplicative -> unary .

    Assign          shift and go to state 68
    Mul             reduce using rule 39 (multiplicative -> unary .)
    Div             reduce using rule 39 (multiplicative -> unary .)
    Mod             reduce using rule 39 (multiplicative -> unary .)
    Plus            reduce using rule 39 (multiplicative -> unary .)
    Minus           reduce using rule 39 (multiplicative -> unary .)
    Less            reduce using rule 39 (multiplicative -> unary .)
    Greater         reduce using rule 39 (multiplicative -> unary .)
    LessEqual       reduce using rule 39 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 39 (multiplicative -> unary .)
    NotEqual        reduce using rule 39 (multiplicative -> unary .)
    Equal           reduce using rule 39 (multiplicative -> unary .)
    BitAnd          reduce using rule 39 (multiplicative -> unary .)
    Xor             reduce using rule 39 (multiplicative -> unary .)
    BitOr           reduce using rule 39 (multiplicative -> unary .)
    And             reduce using rule 39 (multiplicative -> unary .)
    Question        reduce using rule 39 (multiplicative -> unary .)
    Or              reduce using rule 39 (multiplicative -> unary .)
    Semi            reduce using rule 39 (multiplicative -> unary .)
    RParen          reduce using rule 39 (multiplicative -> unary .)
    Comma           reduce using rule 39 (multiplicative -> unary .)
    RBracket        reduce using rule 39 (multiplicative -> unary .)
    Colon           reduce using rule 39 (multiplicative -> unary .)


state 36

    (30) conditional -> logical_or .
    (62) conditional -> logical_or . Question expression Colon conditional
    (46) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 30 (conditional -> logical_or .)
    RParen          reduce using rule 30 (conditional -> logical_or .)
    Comma           reduce using rule 30 (conditional -> logical_or .)
    RBracket        reduce using rule 30 (conditional -> logical_or .)
    Colon           reduce using rule 30 (conditional -> logical_or .)
    Question        shift and go to state 69
    Or              shift and go to state 70


state 37

    (40) unary -> postfix .

    Assign          reduce using rule 40 (unary -> postfix .)
    Mul             reduce using rule 40 (unary -> postfix .)
    Div             reduce using rule 40 (unary -> postfix .)
    Mod             reduce using rule 40 (unary -> postfix .)
    Plus            reduce using rule 40 (unary -> postfix .)
    Minus           reduce using rule 40 (unary -> postfix .)
    Less            reduce using rule 40 (unary -> postfix .)
    Greater         reduce using rule 40 (unary -> postfix .)
    LessEqual       reduce using rule 40 (unary -> postfix .)
    GreaterEqual    reduce using rule 40 (unary -> postfix .)
    NotEqual        reduce using rule 40 (unary -> postfix .)
    Equal           reduce using rule 40 (unary -> postfix .)
    BitAnd          reduce using rule 40 (unary -> postfix .)
    Xor             reduce using rule 40 (unary -> postfix .)
    BitOr           reduce using rule 40 (unary -> postfix .)
    And             reduce using rule 40 (unary -> postfix .)
    Question        reduce using rule 40 (unary -> postfix .)
    Or              reduce using rule 40 (unary -> postfix .)
    Semi            reduce using rule 40 (unary -> postfix .)
    RParen          reduce using rule 40 (unary -> postfix .)
    Comma           reduce using rule 40 (unary -> postfix .)
    RBracket        reduce using rule 40 (unary -> postfix .)
    Colon           reduce using rule 40 (unary -> postfix .)


state 38

    (42) unary -> Minus . unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 71
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 39

    (43) unary -> BitNot . unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 72
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 40

    (44) unary -> Not . unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 73
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 41

    (31) logical_or -> logical_and .
    (47) logical_and -> logical_and . And bit_or

    Question        reduce using rule 31 (logical_or -> logical_and .)
    Or              reduce using rule 31 (logical_or -> logical_and .)
    Semi            reduce using rule 31 (logical_or -> logical_and .)
    RParen          reduce using rule 31 (logical_or -> logical_and .)
    Comma           reduce using rule 31 (logical_or -> logical_and .)
    RBracket        reduce using rule 31 (logical_or -> logical_and .)
    Colon           reduce using rule 31 (logical_or -> logical_and .)
    And             shift and go to state 74


state 42

    (41) postfix -> primary .

    Assign          reduce using rule 41 (postfix -> primary .)
    Mul             reduce using rule 41 (postfix -> primary .)
    Div             reduce using rule 41 (postfix -> primary .)
    Mod             reduce using rule 41 (postfix -> primary .)
    Plus            reduce using rule 41 (postfix -> primary .)
    Minus           reduce using rule 41 (postfix -> primary .)
    Less            reduce using rule 41 (postfix -> primary .)
    Greater         reduce using rule 41 (postfix -> primary .)
    LessEqual       reduce using rule 41 (postfix -> primary .)
    GreaterEqual    reduce using rule 41 (postfix -> primary .)
    NotEqual        reduce using rule 41 (postfix -> primary .)
    Equal           reduce using rule 41 (postfix -> primary .)
    BitAnd          reduce using rule 41 (postfix -> primary .)
    Xor             reduce using rule 41 (postfix -> primary .)
    BitOr           reduce using rule 41 (postfix -> primary .)
    And             reduce using rule 41 (postfix -> primary .)
    Question        reduce using rule 41 (postfix -> primary .)
    Or              reduce using rule 41 (postfix -> primary .)
    Semi            reduce using rule 41 (postfix -> primary .)
    RParen          reduce using rule 41 (postfix -> primary .)
    Comma           reduce using rule 41 (postfix -> primary .)
    RBracket        reduce using rule 41 (postfix -> primary .)
    Colon           reduce using rule 41 (postfix -> primary .)


state 43

    (65) primary -> LParen . expression RParen
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 75
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 44

    (87) postfix -> multidim_arr .
    (91) multidim_arr -> multidim_arr . LBracket expression RBracket

    Assign          reduce using rule 87 (postfix -> multidim_arr .)
    Mul             reduce using rule 87 (postfix -> multidim_arr .)
    Div             reduce using rule 87 (postfix -> multidim_arr .)
    Mod             reduce using rule 87 (postfix -> multidim_arr .)
    Plus            reduce using rule 87 (postfix -> multidim_arr .)
    Minus           reduce using rule 87 (postfix -> multidim_arr .)
    Less            reduce using rule 87 (postfix -> multidim_arr .)
    Greater         reduce using rule 87 (postfix -> multidim_arr .)
    LessEqual       reduce using rule 87 (postfix -> multidim_arr .)
    GreaterEqual    reduce using rule 87 (postfix -> multidim_arr .)
    NotEqual        reduce using rule 87 (postfix -> multidim_arr .)
    Equal           reduce using rule 87 (postfix -> multidim_arr .)
    BitAnd          reduce using rule 87 (postfix -> multidim_arr .)
    Xor             reduce using rule 87 (postfix -> multidim_arr .)
    BitOr           reduce using rule 87 (postfix -> multidim_arr .)
    And             reduce using rule 87 (postfix -> multidim_arr .)
    Question        reduce using rule 87 (postfix -> multidim_arr .)
    Or              reduce using rule 87 (postfix -> multidim_arr .)
    Semi            reduce using rule 87 (postfix -> multidim_arr .)
    RParen          reduce using rule 87 (postfix -> multidim_arr .)
    Comma           reduce using rule 87 (postfix -> multidim_arr .)
    RBracket        reduce using rule 87 (postfix -> multidim_arr .)
    Colon           reduce using rule 87 (postfix -> multidim_arr .)
    LBracket        shift and go to state 76


state 45

    (88) postfix -> singledim_arr .
    (90) multidim_arr -> singledim_arr . LBracket expression RBracket

    Assign          reduce using rule 88 (postfix -> singledim_arr .)
    Mul             reduce using rule 88 (postfix -> singledim_arr .)
    Div             reduce using rule 88 (postfix -> singledim_arr .)
    Mod             reduce using rule 88 (postfix -> singledim_arr .)
    Plus            reduce using rule 88 (postfix -> singledim_arr .)
    Minus           reduce using rule 88 (postfix -> singledim_arr .)
    Less            reduce using rule 88 (postfix -> singledim_arr .)
    Greater         reduce using rule 88 (postfix -> singledim_arr .)
    LessEqual       reduce using rule 88 (postfix -> singledim_arr .)
    GreaterEqual    reduce using rule 88 (postfix -> singledim_arr .)
    NotEqual        reduce using rule 88 (postfix -> singledim_arr .)
    Equal           reduce using rule 88 (postfix -> singledim_arr .)
    BitAnd          reduce using rule 88 (postfix -> singledim_arr .)
    Xor             reduce using rule 88 (postfix -> singledim_arr .)
    BitOr           reduce using rule 88 (postfix -> singledim_arr .)
    And             reduce using rule 88 (postfix -> singledim_arr .)
    Question        reduce using rule 88 (postfix -> singledim_arr .)
    Or              reduce using rule 88 (postfix -> singledim_arr .)
    Semi            reduce using rule 88 (postfix -> singledim_arr .)
    RParen          reduce using rule 88 (postfix -> singledim_arr .)
    Comma           reduce using rule 88 (postfix -> singledim_arr .)
    RBracket        reduce using rule 88 (postfix -> singledim_arr .)
    Colon           reduce using rule 88 (postfix -> singledim_arr .)
    LBracket        shift and go to state 77


state 46

    (32) logical_and -> bit_or .
    (48) bit_or -> bit_or . BitOr xor

    And             reduce using rule 32 (logical_and -> bit_or .)
    Question        reduce using rule 32 (logical_and -> bit_or .)
    Or              reduce using rule 32 (logical_and -> bit_or .)
    Semi            reduce using rule 32 (logical_and -> bit_or .)
    RParen          reduce using rule 32 (logical_and -> bit_or .)
    Comma           reduce using rule 32 (logical_and -> bit_or .)
    RBracket        reduce using rule 32 (logical_and -> bit_or .)
    Colon           reduce using rule 32 (logical_and -> bit_or .)
    BitOr           shift and go to state 78


state 47

    (63) primary -> Integer .

    Assign          reduce using rule 63 (primary -> Integer .)
    Mul             reduce using rule 63 (primary -> Integer .)
    Div             reduce using rule 63 (primary -> Integer .)
    Mod             reduce using rule 63 (primary -> Integer .)
    Plus            reduce using rule 63 (primary -> Integer .)
    Minus           reduce using rule 63 (primary -> Integer .)
    Less            reduce using rule 63 (primary -> Integer .)
    Greater         reduce using rule 63 (primary -> Integer .)
    LessEqual       reduce using rule 63 (primary -> Integer .)
    GreaterEqual    reduce using rule 63 (primary -> Integer .)
    NotEqual        reduce using rule 63 (primary -> Integer .)
    Equal           reduce using rule 63 (primary -> Integer .)
    BitAnd          reduce using rule 63 (primary -> Integer .)
    Xor             reduce using rule 63 (primary -> Integer .)
    BitOr           reduce using rule 63 (primary -> Integer .)
    And             reduce using rule 63 (primary -> Integer .)
    Question        reduce using rule 63 (primary -> Integer .)
    Or              reduce using rule 63 (primary -> Integer .)
    Semi            reduce using rule 63 (primary -> Integer .)
    RParen          reduce using rule 63 (primary -> Integer .)
    Comma           reduce using rule 63 (primary -> Integer .)
    RBracket        reduce using rule 63 (primary -> Integer .)
    Colon           reduce using rule 63 (primary -> Integer .)


state 48

    (33) bit_or -> xor .
    (49) xor -> xor . Xor bit_and

    BitOr           reduce using rule 33 (bit_or -> xor .)
    And             reduce using rule 33 (bit_or -> xor .)
    Question        reduce using rule 33 (bit_or -> xor .)
    Or              reduce using rule 33 (bit_or -> xor .)
    Semi            reduce using rule 33 (bit_or -> xor .)
    RParen          reduce using rule 33 (bit_or -> xor .)
    Comma           reduce using rule 33 (bit_or -> xor .)
    RBracket        reduce using rule 33 (bit_or -> xor .)
    Colon           reduce using rule 33 (bit_or -> xor .)
    Xor             shift and go to state 79


state 49

    (34) xor -> bit_and .
    (50) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 34 (xor -> bit_and .)
    BitOr           reduce using rule 34 (xor -> bit_and .)
    And             reduce using rule 34 (xor -> bit_and .)
    Question        reduce using rule 34 (xor -> bit_and .)
    Or              reduce using rule 34 (xor -> bit_and .)
    Semi            reduce using rule 34 (xor -> bit_and .)
    RParen          reduce using rule 34 (xor -> bit_and .)
    Comma           reduce using rule 34 (xor -> bit_and .)
    RBracket        reduce using rule 34 (xor -> bit_and .)
    Colon           reduce using rule 34 (xor -> bit_and .)
    BitAnd          shift and go to state 80


state 50

    (35) bit_and -> equality .
    (51) equality -> equality . NotEqual relational
    (52) equality -> equality . Equal relational

    BitAnd          reduce using rule 35 (bit_and -> equality .)
    Xor             reduce using rule 35 (bit_and -> equality .)
    BitOr           reduce using rule 35 (bit_and -> equality .)
    And             reduce using rule 35 (bit_and -> equality .)
    Question        reduce using rule 35 (bit_and -> equality .)
    Or              reduce using rule 35 (bit_and -> equality .)
    Semi            reduce using rule 35 (bit_and -> equality .)
    RParen          reduce using rule 35 (bit_and -> equality .)
    Comma           reduce using rule 35 (bit_and -> equality .)
    RBracket        reduce using rule 35 (bit_and -> equality .)
    Colon           reduce using rule 35 (bit_and -> equality .)
    NotEqual        shift and go to state 81
    Equal           shift and go to state 82


state 51

    (36) equality -> relational .
    (53) relational -> relational . Less additive
    (54) relational -> relational . Greater additive
    (55) relational -> relational . LessEqual additive
    (56) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 36 (equality -> relational .)
    Equal           reduce using rule 36 (equality -> relational .)
    BitAnd          reduce using rule 36 (equality -> relational .)
    Xor             reduce using rule 36 (equality -> relational .)
    BitOr           reduce using rule 36 (equality -> relational .)
    And             reduce using rule 36 (equality -> relational .)
    Question        reduce using rule 36 (equality -> relational .)
    Or              reduce using rule 36 (equality -> relational .)
    Semi            reduce using rule 36 (equality -> relational .)
    RParen          reduce using rule 36 (equality -> relational .)
    Comma           reduce using rule 36 (equality -> relational .)
    RBracket        reduce using rule 36 (equality -> relational .)
    Colon           reduce using rule 36 (equality -> relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 52

    (37) relational -> additive .
    (57) additive -> additive . Plus multiplicative
    (58) additive -> additive . Minus multiplicative

    Less            reduce using rule 37 (relational -> additive .)
    Greater         reduce using rule 37 (relational -> additive .)
    LessEqual       reduce using rule 37 (relational -> additive .)
    GreaterEqual    reduce using rule 37 (relational -> additive .)
    NotEqual        reduce using rule 37 (relational -> additive .)
    Equal           reduce using rule 37 (relational -> additive .)
    BitAnd          reduce using rule 37 (relational -> additive .)
    Xor             reduce using rule 37 (relational -> additive .)
    BitOr           reduce using rule 37 (relational -> additive .)
    And             reduce using rule 37 (relational -> additive .)
    Question        reduce using rule 37 (relational -> additive .)
    Or              reduce using rule 37 (relational -> additive .)
    Semi            reduce using rule 37 (relational -> additive .)
    RParen          reduce using rule 37 (relational -> additive .)
    Comma           reduce using rule 37 (relational -> additive .)
    RBracket        reduce using rule 37 (relational -> additive .)
    Colon           reduce using rule 37 (relational -> additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 53

    (38) additive -> multiplicative .
    (59) multiplicative -> multiplicative . Mul unary
    (60) multiplicative -> multiplicative . Div unary
    (61) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 38 (additive -> multiplicative .)
    Minus           reduce using rule 38 (additive -> multiplicative .)
    Less            reduce using rule 38 (additive -> multiplicative .)
    Greater         reduce using rule 38 (additive -> multiplicative .)
    LessEqual       reduce using rule 38 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 38 (additive -> multiplicative .)
    NotEqual        reduce using rule 38 (additive -> multiplicative .)
    Equal           reduce using rule 38 (additive -> multiplicative .)
    BitAnd          reduce using rule 38 (additive -> multiplicative .)
    Xor             reduce using rule 38 (additive -> multiplicative .)
    BitOr           reduce using rule 38 (additive -> multiplicative .)
    And             reduce using rule 38 (additive -> multiplicative .)
    Question        reduce using rule 38 (additive -> multiplicative .)
    Or              reduce using rule 38 (additive -> multiplicative .)
    Semi            reduce using rule 38 (additive -> multiplicative .)
    RParen          reduce using rule 38 (additive -> multiplicative .)
    Comma           reduce using rule 38 (additive -> multiplicative .)
    RBracket        reduce using rule 38 (additive -> multiplicative .)
    Colon           reduce using rule 38 (additive -> multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 54

    (94) singledim_decl -> type Identifier LBracket Integer . RBracket

    RBracket        shift and go to state 92


state 55

    (100) declaration -> multidim_decl Assign LBrace intlist . RBrace
    (99) intlist -> intlist . Comma Integer

    RBrace          shift and go to state 93
    Comma           shift and go to state 94


state 56

    (97) intlist -> empty .

    RBrace          reduce using rule 97 (intlist -> empty .)
    Comma           reduce using rule 97 (intlist -> empty .)


state 57

    (98) intlist -> Integer .

    RBrace          reduce using rule 98 (intlist -> Integer .)
    Comma           reduce using rule 98 (intlist -> Integer .)


state 58

    (96) multidim_decl -> multidim_decl LBracket Integer RBracket .

    Assign          reduce using rule 96 (multidim_decl -> multidim_decl LBracket Integer RBracket .)
    LBracket        reduce using rule 96 (multidim_decl -> multidim_decl LBracket Integer RBracket .)
    Semi            reduce using rule 96 (multidim_decl -> multidim_decl LBracket Integer RBracket .)


state 59

    (101) declaration -> singledim_decl Assign LBrace intlist . RBrace
    (99) intlist -> intlist . Comma Integer

    RBrace          shift and go to state 95
    Comma           shift and go to state 94


state 60

    (95) multidim_decl -> singledim_decl LBracket Integer RBracket .

    Assign          reduce using rule 95 (multidim_decl -> singledim_decl LBracket Integer RBracket .)
    LBracket        reduce using rule 95 (multidim_decl -> singledim_decl LBracket Integer RBracket .)
    Semi            reduce using rule 95 (multidim_decl -> singledim_decl LBracket Integer RBracket .)


state 61

    (79) parameter_item -> type Identifier .

    LBracket        reduce using rule 79 (parameter_item -> type Identifier .)
    RParen          reduce using rule 79 (parameter_item -> type Identifier .)
    Comma           reduce using rule 79 (parameter_item -> type Identifier .)


state 62

    (7) function -> type Identifier LParen parameter_list RParen . LBrace block RBrace
    (8) function -> type Identifier LParen parameter_list RParen . Semi

    LBrace          shift and go to state 96
    Semi            shift and go to state 97


state 63

    (80) parameter_list -> parameter_list Comma . parameter
    (73) parameter -> . parameter_item
    (74) parameter -> . parameter_arr_single
    (75) parameter -> . parameter_arr_multi
    (79) parameter_item -> . type Identifier
    (76) parameter_arr_single -> . parameter_item LBracket empty RBracket
    (77) parameter_arr_single -> . parameter_item LBracket Integer RBracket
    (78) parameter_arr_multi -> . parameter_arr_single LBracket Integer RBracket
    (6) type -> . Int

    Int             shift and go to state 7

    parameter                      shift and go to state 98
    parameter_item                 shift and go to state 28
    parameter_arr_single           shift and go to state 29
    parameter_arr_multi            shift and go to state 30
    type                           shift and go to state 24

state 64

    (76) parameter_arr_single -> parameter_item LBracket . empty RBracket
    (77) parameter_arr_single -> parameter_item LBracket . Integer RBracket
    (1) empty -> .

    Integer         shift and go to state 100
    RBracket        reduce using rule 1 (empty -> .)

    empty                          shift and go to state 99

state 65

    (78) parameter_arr_multi -> parameter_arr_single LBracket . Integer RBracket

    Integer         shift and go to state 101


state 66

    (86) postfix -> Identifier LParen . expression_list RParen
    (83) expression_list -> . expression_list Comma expression
    (84) expression_list -> . expression
    (85) expression_list -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression_list                shift and go to state 102
    expression                     shift and go to state 103
    empty                          shift and go to state 104
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 67

    (89) singledim_arr -> Identifier LBracket . expression RBracket
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 105
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 68

    (45) assignment -> unary Assign . expression
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 35
    expression                     shift and go to state 106
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 69

    (62) conditional -> logical_or Question . expression Colon conditional
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    logical_or                     shift and go to state 36
    expression                     shift and go to state 107
    conditional                    shift and go to state 34
    assignment                     shift and go to state 33
    unary                          shift and go to state 35
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 70

    (46) logical_or -> logical_or Or . logical_and
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    logical_and                    shift and go to state 108
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 71

    (42) unary -> Minus unary .

    Assign          reduce using rule 42 (unary -> Minus unary .)
    Mul             reduce using rule 42 (unary -> Minus unary .)
    Div             reduce using rule 42 (unary -> Minus unary .)
    Mod             reduce using rule 42 (unary -> Minus unary .)
    Plus            reduce using rule 42 (unary -> Minus unary .)
    Minus           reduce using rule 42 (unary -> Minus unary .)
    Less            reduce using rule 42 (unary -> Minus unary .)
    Greater         reduce using rule 42 (unary -> Minus unary .)
    LessEqual       reduce using rule 42 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 42 (unary -> Minus unary .)
    NotEqual        reduce using rule 42 (unary -> Minus unary .)
    Equal           reduce using rule 42 (unary -> Minus unary .)
    BitAnd          reduce using rule 42 (unary -> Minus unary .)
    Xor             reduce using rule 42 (unary -> Minus unary .)
    BitOr           reduce using rule 42 (unary -> Minus unary .)
    And             reduce using rule 42 (unary -> Minus unary .)
    Question        reduce using rule 42 (unary -> Minus unary .)
    Or              reduce using rule 42 (unary -> Minus unary .)
    Semi            reduce using rule 42 (unary -> Minus unary .)
    RParen          reduce using rule 42 (unary -> Minus unary .)
    Comma           reduce using rule 42 (unary -> Minus unary .)
    RBracket        reduce using rule 42 (unary -> Minus unary .)
    Colon           reduce using rule 42 (unary -> Minus unary .)


state 72

    (43) unary -> BitNot unary .

    Assign          reduce using rule 43 (unary -> BitNot unary .)
    Mul             reduce using rule 43 (unary -> BitNot unary .)
    Div             reduce using rule 43 (unary -> BitNot unary .)
    Mod             reduce using rule 43 (unary -> BitNot unary .)
    Plus            reduce using rule 43 (unary -> BitNot unary .)
    Minus           reduce using rule 43 (unary -> BitNot unary .)
    Less            reduce using rule 43 (unary -> BitNot unary .)
    Greater         reduce using rule 43 (unary -> BitNot unary .)
    LessEqual       reduce using rule 43 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 43 (unary -> BitNot unary .)
    NotEqual        reduce using rule 43 (unary -> BitNot unary .)
    Equal           reduce using rule 43 (unary -> BitNot unary .)
    BitAnd          reduce using rule 43 (unary -> BitNot unary .)
    Xor             reduce using rule 43 (unary -> BitNot unary .)
    BitOr           reduce using rule 43 (unary -> BitNot unary .)
    And             reduce using rule 43 (unary -> BitNot unary .)
    Question        reduce using rule 43 (unary -> BitNot unary .)
    Or              reduce using rule 43 (unary -> BitNot unary .)
    Semi            reduce using rule 43 (unary -> BitNot unary .)
    RParen          reduce using rule 43 (unary -> BitNot unary .)
    Comma           reduce using rule 43 (unary -> BitNot unary .)
    RBracket        reduce using rule 43 (unary -> BitNot unary .)
    Colon           reduce using rule 43 (unary -> BitNot unary .)


state 73

    (44) unary -> Not unary .

    Assign          reduce using rule 44 (unary -> Not unary .)
    Mul             reduce using rule 44 (unary -> Not unary .)
    Div             reduce using rule 44 (unary -> Not unary .)
    Mod             reduce using rule 44 (unary -> Not unary .)
    Plus            reduce using rule 44 (unary -> Not unary .)
    Minus           reduce using rule 44 (unary -> Not unary .)
    Less            reduce using rule 44 (unary -> Not unary .)
    Greater         reduce using rule 44 (unary -> Not unary .)
    LessEqual       reduce using rule 44 (unary -> Not unary .)
    GreaterEqual    reduce using rule 44 (unary -> Not unary .)
    NotEqual        reduce using rule 44 (unary -> Not unary .)
    Equal           reduce using rule 44 (unary -> Not unary .)
    BitAnd          reduce using rule 44 (unary -> Not unary .)
    Xor             reduce using rule 44 (unary -> Not unary .)
    BitOr           reduce using rule 44 (unary -> Not unary .)
    And             reduce using rule 44 (unary -> Not unary .)
    Question        reduce using rule 44 (unary -> Not unary .)
    Or              reduce using rule 44 (unary -> Not unary .)
    Semi            reduce using rule 44 (unary -> Not unary .)
    RParen          reduce using rule 44 (unary -> Not unary .)
    Comma           reduce using rule 44 (unary -> Not unary .)
    RBracket        reduce using rule 44 (unary -> Not unary .)
    Colon           reduce using rule 44 (unary -> Not unary .)


state 74

    (47) logical_and -> logical_and And . bit_or
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    bit_or                         shift and go to state 110
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 75

    (65) primary -> LParen expression . RParen

    RParen          shift and go to state 111


state 76

    (91) multidim_arr -> multidim_arr LBracket . expression RBracket
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    multidim_arr                   shift and go to state 44
    expression                     shift and go to state 112
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 77

    (90) multidim_arr -> singledim_arr LBracket . expression RBracket
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    singledim_arr                  shift and go to state 45
    expression                     shift and go to state 113
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 78

    (48) bit_or -> bit_or BitOr . xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    xor                            shift and go to state 114
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 79

    (49) xor -> xor Xor . bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    bit_and                        shift and go to state 115
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 80

    (50) bit_and -> bit_and BitAnd . equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    equality                       shift and go to state 116
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 81

    (51) equality -> equality NotEqual . relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    relational                     shift and go to state 117
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 82

    (52) equality -> equality Equal . relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    relational                     shift and go to state 118
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 83

    (53) relational -> relational Less . additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    additive                       shift and go to state 119
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 84

    (54) relational -> relational Greater . additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    additive                       shift and go to state 120
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 85

    (55) relational -> relational LessEqual . additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    additive                       shift and go to state 121
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 86

    (56) relational -> relational GreaterEqual . additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    additive                       shift and go to state 122
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 87

    (57) additive -> additive Plus . multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    multiplicative                 shift and go to state 123
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 88

    (58) additive -> additive Minus . multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    multiplicative                 shift and go to state 124
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 89

    (59) multiplicative -> multiplicative Mul . unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 125
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 90

    (60) multiplicative -> multiplicative Div . unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 126
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 91

    (61) multiplicative -> multiplicative Mod . unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    unary                          shift and go to state 127
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 92

    (94) singledim_decl -> type Identifier LBracket Integer RBracket .

    Assign          reduce using rule 94 (singledim_decl -> type Identifier LBracket Integer RBracket .)
    LBracket        reduce using rule 94 (singledim_decl -> type Identifier LBracket Integer RBracket .)
    Semi            reduce using rule 94 (singledim_decl -> type Identifier LBracket Integer RBracket .)


state 93

    (100) declaration -> multidim_decl Assign LBrace intlist RBrace .

    Semi            reduce using rule 100 (declaration -> multidim_decl Assign LBrace intlist RBrace .)


state 94

    (99) intlist -> intlist Comma . Integer

    Integer         shift and go to state 128


state 95

    (101) declaration -> singledim_decl Assign LBrace intlist RBrace .

    Semi            reduce using rule 101 (declaration -> singledim_decl Assign LBrace intlist RBrace .)


state 96

    (7) function -> type Identifier LParen parameter_list RParen LBrace . block RBrace
    (9) block -> . block block_item
    (10) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 129
    empty                          shift and go to state 130

state 97

    (8) function -> type Identifier LParen parameter_list RParen Semi .

    Int             reduce using rule 8 (function -> type Identifier LParen parameter_list RParen Semi .)
    $end            reduce using rule 8 (function -> type Identifier LParen parameter_list RParen Semi .)


state 98

    (80) parameter_list -> parameter_list Comma parameter .

    RParen          reduce using rule 80 (parameter_list -> parameter_list Comma parameter .)
    Comma           reduce using rule 80 (parameter_list -> parameter_list Comma parameter .)


state 99

    (76) parameter_arr_single -> parameter_item LBracket empty . RBracket

    RBracket        shift and go to state 131


state 100

    (77) parameter_arr_single -> parameter_item LBracket Integer . RBracket

    RBracket        shift and go to state 132


state 101

    (78) parameter_arr_multi -> parameter_arr_single LBracket Integer . RBracket

    RBracket        shift and go to state 133


state 102

    (86) postfix -> Identifier LParen expression_list . RParen
    (83) expression_list -> expression_list . Comma expression

    RParen          shift and go to state 134
    Comma           shift and go to state 135


state 103

    (84) expression_list -> expression .

    RParen          reduce using rule 84 (expression_list -> expression .)
    Comma           reduce using rule 84 (expression_list -> expression .)


state 104

    (85) expression_list -> empty .

    RParen          reduce using rule 85 (expression_list -> empty .)
    Comma           reduce using rule 85 (expression_list -> empty .)


state 105

    (89) singledim_arr -> Identifier LBracket expression . RBracket

    RBracket        shift and go to state 136


state 106

    (45) assignment -> unary Assign expression .

    Semi            reduce using rule 45 (assignment -> unary Assign expression .)
    RParen          reduce using rule 45 (assignment -> unary Assign expression .)
    Comma           reduce using rule 45 (assignment -> unary Assign expression .)
    RBracket        reduce using rule 45 (assignment -> unary Assign expression .)
    Colon           reduce using rule 45 (assignment -> unary Assign expression .)


state 107

    (62) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 137


state 108

    (46) logical_or -> logical_or Or logical_and .
    (47) logical_and -> logical_and . And bit_or

    Question        reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    RBracket        reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 46 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 74


state 109

    (39) multiplicative -> unary .

    Mul             reduce using rule 39 (multiplicative -> unary .)
    Div             reduce using rule 39 (multiplicative -> unary .)
    Mod             reduce using rule 39 (multiplicative -> unary .)
    Plus            reduce using rule 39 (multiplicative -> unary .)
    Minus           reduce using rule 39 (multiplicative -> unary .)
    Less            reduce using rule 39 (multiplicative -> unary .)
    Greater         reduce using rule 39 (multiplicative -> unary .)
    LessEqual       reduce using rule 39 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 39 (multiplicative -> unary .)
    NotEqual        reduce using rule 39 (multiplicative -> unary .)
    Equal           reduce using rule 39 (multiplicative -> unary .)
    BitAnd          reduce using rule 39 (multiplicative -> unary .)
    Xor             reduce using rule 39 (multiplicative -> unary .)
    BitOr           reduce using rule 39 (multiplicative -> unary .)
    And             reduce using rule 39 (multiplicative -> unary .)
    Question        reduce using rule 39 (multiplicative -> unary .)
    Or              reduce using rule 39 (multiplicative -> unary .)
    Semi            reduce using rule 39 (multiplicative -> unary .)
    RParen          reduce using rule 39 (multiplicative -> unary .)
    Comma           reduce using rule 39 (multiplicative -> unary .)
    RBracket        reduce using rule 39 (multiplicative -> unary .)
    Colon           reduce using rule 39 (multiplicative -> unary .)


state 110

    (47) logical_and -> logical_and And bit_or .
    (48) bit_or -> bit_or . BitOr xor

    And             reduce using rule 47 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 47 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 47 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 47 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 47 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 47 (logical_and -> logical_and And bit_or .)
    RBracket        reduce using rule 47 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 47 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 78


state 111

    (65) primary -> LParen expression RParen .

    Assign          reduce using rule 65 (primary -> LParen expression RParen .)
    Mul             reduce using rule 65 (primary -> LParen expression RParen .)
    Div             reduce using rule 65 (primary -> LParen expression RParen .)
    Mod             reduce using rule 65 (primary -> LParen expression RParen .)
    Plus            reduce using rule 65 (primary -> LParen expression RParen .)
    Minus           reduce using rule 65 (primary -> LParen expression RParen .)
    Less            reduce using rule 65 (primary -> LParen expression RParen .)
    Greater         reduce using rule 65 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 65 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 65 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 65 (primary -> LParen expression RParen .)
    Equal           reduce using rule 65 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 65 (primary -> LParen expression RParen .)
    Xor             reduce using rule 65 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 65 (primary -> LParen expression RParen .)
    And             reduce using rule 65 (primary -> LParen expression RParen .)
    Question        reduce using rule 65 (primary -> LParen expression RParen .)
    Or              reduce using rule 65 (primary -> LParen expression RParen .)
    Semi            reduce using rule 65 (primary -> LParen expression RParen .)
    RParen          reduce using rule 65 (primary -> LParen expression RParen .)
    Comma           reduce using rule 65 (primary -> LParen expression RParen .)
    RBracket        reduce using rule 65 (primary -> LParen expression RParen .)
    Colon           reduce using rule 65 (primary -> LParen expression RParen .)


state 112

    (91) multidim_arr -> multidim_arr LBracket expression . RBracket

    RBracket        shift and go to state 138


state 113

    (90) multidim_arr -> singledim_arr LBracket expression . RBracket

    RBracket        shift and go to state 139


state 114

    (48) bit_or -> bit_or BitOr xor .
    (49) xor -> xor . Xor bit_and

    BitOr           reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    RBracket        reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 48 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 79


state 115

    (49) xor -> xor Xor bit_and .
    (50) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 49 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 49 (xor -> xor Xor bit_and .)
    And             reduce using rule 49 (xor -> xor Xor bit_and .)
    Question        reduce using rule 49 (xor -> xor Xor bit_and .)
    Or              reduce using rule 49 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 49 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 49 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 49 (xor -> xor Xor bit_and .)
    RBracket        reduce using rule 49 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 49 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 80


state 116

    (50) bit_and -> bit_and BitAnd equality .
    (51) equality -> equality . NotEqual relational
    (52) equality -> equality . Equal relational

    BitAnd          reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    RBracket        reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 50 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 81
    Equal           shift and go to state 82


state 117

    (51) equality -> equality NotEqual relational .
    (53) relational -> relational . Less additive
    (54) relational -> relational . Greater additive
    (55) relational -> relational . LessEqual additive
    (56) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 51 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 51 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 51 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 51 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 51 (equality -> equality NotEqual relational .)
    And             reduce using rule 51 (equality -> equality NotEqual relational .)
    Question        reduce using rule 51 (equality -> equality NotEqual relational .)
    Or              reduce using rule 51 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 51 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 51 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 51 (equality -> equality NotEqual relational .)
    RBracket        reduce using rule 51 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 51 (equality -> equality NotEqual relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 118

    (52) equality -> equality Equal relational .
    (53) relational -> relational . Less additive
    (54) relational -> relational . Greater additive
    (55) relational -> relational . LessEqual additive
    (56) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 52 (equality -> equality Equal relational .)
    Equal           reduce using rule 52 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 52 (equality -> equality Equal relational .)
    Xor             reduce using rule 52 (equality -> equality Equal relational .)
    BitOr           reduce using rule 52 (equality -> equality Equal relational .)
    And             reduce using rule 52 (equality -> equality Equal relational .)
    Question        reduce using rule 52 (equality -> equality Equal relational .)
    Or              reduce using rule 52 (equality -> equality Equal relational .)
    Semi            reduce using rule 52 (equality -> equality Equal relational .)
    RParen          reduce using rule 52 (equality -> equality Equal relational .)
    Comma           reduce using rule 52 (equality -> equality Equal relational .)
    RBracket        reduce using rule 52 (equality -> equality Equal relational .)
    Colon           reduce using rule 52 (equality -> equality Equal relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 119

    (53) relational -> relational Less additive .
    (57) additive -> additive . Plus multiplicative
    (58) additive -> additive . Minus multiplicative

    Less            reduce using rule 53 (relational -> relational Less additive .)
    Greater         reduce using rule 53 (relational -> relational Less additive .)
    LessEqual       reduce using rule 53 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 53 (relational -> relational Less additive .)
    NotEqual        reduce using rule 53 (relational -> relational Less additive .)
    Equal           reduce using rule 53 (relational -> relational Less additive .)
    BitAnd          reduce using rule 53 (relational -> relational Less additive .)
    Xor             reduce using rule 53 (relational -> relational Less additive .)
    BitOr           reduce using rule 53 (relational -> relational Less additive .)
    And             reduce using rule 53 (relational -> relational Less additive .)
    Question        reduce using rule 53 (relational -> relational Less additive .)
    Or              reduce using rule 53 (relational -> relational Less additive .)
    Semi            reduce using rule 53 (relational -> relational Less additive .)
    RParen          reduce using rule 53 (relational -> relational Less additive .)
    Comma           reduce using rule 53 (relational -> relational Less additive .)
    RBracket        reduce using rule 53 (relational -> relational Less additive .)
    Colon           reduce using rule 53 (relational -> relational Less additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 120

    (54) relational -> relational Greater additive .
    (57) additive -> additive . Plus multiplicative
    (58) additive -> additive . Minus multiplicative

    Less            reduce using rule 54 (relational -> relational Greater additive .)
    Greater         reduce using rule 54 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 54 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 54 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 54 (relational -> relational Greater additive .)
    Equal           reduce using rule 54 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 54 (relational -> relational Greater additive .)
    Xor             reduce using rule 54 (relational -> relational Greater additive .)
    BitOr           reduce using rule 54 (relational -> relational Greater additive .)
    And             reduce using rule 54 (relational -> relational Greater additive .)
    Question        reduce using rule 54 (relational -> relational Greater additive .)
    Or              reduce using rule 54 (relational -> relational Greater additive .)
    Semi            reduce using rule 54 (relational -> relational Greater additive .)
    RParen          reduce using rule 54 (relational -> relational Greater additive .)
    Comma           reduce using rule 54 (relational -> relational Greater additive .)
    RBracket        reduce using rule 54 (relational -> relational Greater additive .)
    Colon           reduce using rule 54 (relational -> relational Greater additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 121

    (55) relational -> relational LessEqual additive .
    (57) additive -> additive . Plus multiplicative
    (58) additive -> additive . Minus multiplicative

    Less            reduce using rule 55 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 55 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 55 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 55 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 55 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 55 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 55 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 55 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 55 (relational -> relational LessEqual additive .)
    And             reduce using rule 55 (relational -> relational LessEqual additive .)
    Question        reduce using rule 55 (relational -> relational LessEqual additive .)
    Or              reduce using rule 55 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 55 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 55 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 55 (relational -> relational LessEqual additive .)
    RBracket        reduce using rule 55 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 55 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 122

    (56) relational -> relational GreaterEqual additive .
    (57) additive -> additive . Plus multiplicative
    (58) additive -> additive . Minus multiplicative

    Less            reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 56 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 56 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 56 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 56 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 56 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 56 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 56 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 56 (relational -> relational GreaterEqual additive .)
    RBracket        reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 56 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 123

    (57) additive -> additive Plus multiplicative .
    (59) multiplicative -> multiplicative . Mul unary
    (60) multiplicative -> multiplicative . Div unary
    (61) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 57 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 57 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 57 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 57 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 57 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 57 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 57 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 57 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 57 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 57 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 57 (additive -> additive Plus multiplicative .)
    And             reduce using rule 57 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 57 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 57 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 57 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 57 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 57 (additive -> additive Plus multiplicative .)
    RBracket        reduce using rule 57 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 57 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 124

    (58) additive -> additive Minus multiplicative .
    (59) multiplicative -> multiplicative . Mul unary
    (60) multiplicative -> multiplicative . Div unary
    (61) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 58 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 58 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 58 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 58 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 58 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 58 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 58 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 58 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 58 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 58 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 58 (additive -> additive Minus multiplicative .)
    And             reduce using rule 58 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 58 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 58 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 58 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 58 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 58 (additive -> additive Minus multiplicative .)
    RBracket        reduce using rule 58 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 58 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 125

    (59) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    RBracket        reduce using rule 59 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 59 (multiplicative -> multiplicative Mul unary .)


state 126

    (60) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    RBracket        reduce using rule 60 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 60 (multiplicative -> multiplicative Div unary .)


state 127

    (61) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    RBracket        reduce using rule 61 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 61 (multiplicative -> multiplicative Mod unary .)


state 128

    (99) intlist -> intlist Comma Integer .

    RBrace          reduce using rule 99 (intlist -> intlist Comma Integer .)
    Comma           reduce using rule 99 (intlist -> intlist Comma Integer .)


state 129

    (7) function -> type Identifier LParen parameter_list RParen LBrace block . RBrace
    (9) block -> block . block_item
    (11) block_item -> . statement
    (12) block_item -> . declaration Semi
    (13) statement -> . statement_matched
    (14) statement -> . statement_unmatched
    (26) declaration -> . type Identifier
    (27) declaration -> . type Identifier Assign expression
    (92) declaration -> . multidim_decl
    (93) declaration -> . singledim_decl
    (100) declaration -> . multidim_decl Assign LBrace intlist RBrace
    (101) declaration -> . singledim_decl Assign LBrace intlist RBrace
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (6) type -> . Int
    (95) multidim_decl -> . singledim_decl LBracket Integer RBracket
    (96) multidim_decl -> . multidim_decl LBracket Integer RBracket
    (94) singledim_decl -> . type Identifier LBracket Integer RBracket
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    RBrace          shift and go to state 142
    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    type                           shift and go to state 140
    block_item                     shift and go to state 143
    statement                      shift and go to state 144
    declaration                    shift and go to state 145
    statement_matched              shift and go to state 146
    statement_unmatched            shift and go to state 147
    expression                     shift and go to state 148
    multidim_decl                  shift and go to state 5
    singledim_decl                 shift and go to state 6
    opt_expression                 shift and go to state 152
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 130

    (10) block -> empty .

    RBrace          reduce using rule 10 (block -> empty .)
    If              reduce using rule 10 (block -> empty .)
    While           reduce using rule 10 (block -> empty .)
    Return          reduce using rule 10 (block -> empty .)
    LBrace          reduce using rule 10 (block -> empty .)
    Break           reduce using rule 10 (block -> empty .)
    For             reduce using rule 10 (block -> empty .)
    Do              reduce using rule 10 (block -> empty .)
    Continue        reduce using rule 10 (block -> empty .)
    Int             reduce using rule 10 (block -> empty .)
    Minus           reduce using rule 10 (block -> empty .)
    BitNot          reduce using rule 10 (block -> empty .)
    Not             reduce using rule 10 (block -> empty .)
    Identifier      reduce using rule 10 (block -> empty .)
    Integer         reduce using rule 10 (block -> empty .)
    LParen          reduce using rule 10 (block -> empty .)
    Semi            reduce using rule 10 (block -> empty .)


state 131

    (76) parameter_arr_single -> parameter_item LBracket empty RBracket .

    LBracket        reduce using rule 76 (parameter_arr_single -> parameter_item LBracket empty RBracket .)
    RParen          reduce using rule 76 (parameter_arr_single -> parameter_item LBracket empty RBracket .)
    Comma           reduce using rule 76 (parameter_arr_single -> parameter_item LBracket empty RBracket .)


state 132

    (77) parameter_arr_single -> parameter_item LBracket Integer RBracket .

    LBracket        reduce using rule 77 (parameter_arr_single -> parameter_item LBracket Integer RBracket .)
    RParen          reduce using rule 77 (parameter_arr_single -> parameter_item LBracket Integer RBracket .)
    Comma           reduce using rule 77 (parameter_arr_single -> parameter_item LBracket Integer RBracket .)


state 133

    (78) parameter_arr_multi -> parameter_arr_single LBracket Integer RBracket .

    RParen          reduce using rule 78 (parameter_arr_multi -> parameter_arr_single LBracket Integer RBracket .)
    Comma           reduce using rule 78 (parameter_arr_multi -> parameter_arr_single LBracket Integer RBracket .)


state 134

    (86) postfix -> Identifier LParen expression_list RParen .

    Assign          reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Mul             reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    RBracket        reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 86 (postfix -> Identifier LParen expression_list RParen .)


state 135

    (83) expression_list -> expression_list Comma . expression
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 158
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 136

    (89) singledim_arr -> Identifier LBracket expression RBracket .

    LBracket        reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Assign          reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Mul             reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Div             reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Mod             reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Plus            reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Minus           reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Less            reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Greater         reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    LessEqual       reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    GreaterEqual    reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    NotEqual        reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Equal           reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    BitAnd          reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Xor             reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    BitOr           reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    And             reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Question        reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Or              reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Semi            reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    RParen          reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Comma           reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    RBracket        reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)
    Colon           reduce using rule 89 (singledim_arr -> Identifier LBracket expression RBracket .)


state 137

    (62) conditional -> logical_or Question expression Colon . conditional
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    logical_or                     shift and go to state 36
    conditional                    shift and go to state 159
    logical_and                    shift and go to state 41
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53
    unary                          shift and go to state 109
    postfix                        shift and go to state 37
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45

state 138

    (91) multidim_arr -> multidim_arr LBracket expression RBracket .

    LBracket        reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Assign          reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Mul             reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Div             reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Mod             reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Plus            reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Minus           reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Less            reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Greater         reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    LessEqual       reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    GreaterEqual    reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    NotEqual        reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Equal           reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    BitAnd          reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Xor             reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    BitOr           reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    And             reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Question        reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Or              reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Semi            reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    RParen          reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Comma           reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    RBracket        reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)
    Colon           reduce using rule 91 (multidim_arr -> multidim_arr LBracket expression RBracket .)


state 139

    (90) multidim_arr -> singledim_arr LBracket expression RBracket .

    LBracket        reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Assign          reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Mul             reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Div             reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Mod             reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Plus            reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Minus           reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Less            reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Greater         reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    LessEqual       reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    GreaterEqual    reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    NotEqual        reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Equal           reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    BitAnd          reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Xor             reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    BitOr           reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    And             reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Question        reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Or              reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Semi            reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    RParen          reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Comma           reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    RBracket        reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)
    Colon           reduce using rule 90 (multidim_arr -> singledim_arr LBracket expression RBracket .)


state 140

    (26) declaration -> type . Identifier
    (27) declaration -> type . Identifier Assign expression
    (94) singledim_decl -> type . Identifier LBracket Integer RBracket

    Identifier      shift and go to state 160


state 141

    (22) statement_matched -> LBrace . block RBrace
    (9) block -> . block block_item
    (10) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 161
    empty                          shift and go to state 130

state 142

    (7) function -> type Identifier LParen parameter_list RParen LBrace block RBrace .

    Int             reduce using rule 7 (function -> type Identifier LParen parameter_list RParen LBrace block RBrace .)
    $end            reduce using rule 7 (function -> type Identifier LParen parameter_list RParen LBrace block RBrace .)


state 143

    (9) block -> block block_item .

    RBrace          reduce using rule 9 (block -> block block_item .)
    If              reduce using rule 9 (block -> block block_item .)
    While           reduce using rule 9 (block -> block block_item .)
    Return          reduce using rule 9 (block -> block block_item .)
    LBrace          reduce using rule 9 (block -> block block_item .)
    Break           reduce using rule 9 (block -> block block_item .)
    For             reduce using rule 9 (block -> block block_item .)
    Do              reduce using rule 9 (block -> block block_item .)
    Continue        reduce using rule 9 (block -> block block_item .)
    Int             reduce using rule 9 (block -> block block_item .)
    Minus           reduce using rule 9 (block -> block block_item .)
    BitNot          reduce using rule 9 (block -> block block_item .)
    Not             reduce using rule 9 (block -> block block_item .)
    Identifier      reduce using rule 9 (block -> block block_item .)
    Integer         reduce using rule 9 (block -> block block_item .)
    LParen          reduce using rule 9 (block -> block block_item .)
    Semi            reduce using rule 9 (block -> block block_item .)


state 144

    (11) block_item -> statement .

    RBrace          reduce using rule 11 (block_item -> statement .)
    If              reduce using rule 11 (block_item -> statement .)
    While           reduce using rule 11 (block_item -> statement .)
    Return          reduce using rule 11 (block_item -> statement .)
    LBrace          reduce using rule 11 (block_item -> statement .)
    Break           reduce using rule 11 (block_item -> statement .)
    For             reduce using rule 11 (block_item -> statement .)
    Do              reduce using rule 11 (block_item -> statement .)
    Continue        reduce using rule 11 (block_item -> statement .)
    Int             reduce using rule 11 (block_item -> statement .)
    Minus           reduce using rule 11 (block_item -> statement .)
    BitNot          reduce using rule 11 (block_item -> statement .)
    Not             reduce using rule 11 (block_item -> statement .)
    Identifier      reduce using rule 11 (block_item -> statement .)
    Integer         reduce using rule 11 (block_item -> statement .)
    LParen          reduce using rule 11 (block_item -> statement .)
    Semi            reduce using rule 11 (block_item -> statement .)


state 145

    (12) block_item -> declaration . Semi

    Semi            shift and go to state 162


state 146

    (13) statement -> statement_matched .

    RBrace          reduce using rule 13 (statement -> statement_matched .)
    If              reduce using rule 13 (statement -> statement_matched .)
    While           reduce using rule 13 (statement -> statement_matched .)
    Return          reduce using rule 13 (statement -> statement_matched .)
    LBrace          reduce using rule 13 (statement -> statement_matched .)
    Break           reduce using rule 13 (statement -> statement_matched .)
    For             reduce using rule 13 (statement -> statement_matched .)
    Do              reduce using rule 13 (statement -> statement_matched .)
    Continue        reduce using rule 13 (statement -> statement_matched .)
    Int             reduce using rule 13 (statement -> statement_matched .)
    Minus           reduce using rule 13 (statement -> statement_matched .)
    BitNot          reduce using rule 13 (statement -> statement_matched .)
    Not             reduce using rule 13 (statement -> statement_matched .)
    Identifier      reduce using rule 13 (statement -> statement_matched .)
    Integer         reduce using rule 13 (statement -> statement_matched .)
    LParen          reduce using rule 13 (statement -> statement_matched .)
    Semi            reduce using rule 13 (statement -> statement_matched .)


state 147

    (14) statement -> statement_unmatched .

    RBrace          reduce using rule 14 (statement -> statement_unmatched .)
    If              reduce using rule 14 (statement -> statement_unmatched .)
    While           reduce using rule 14 (statement -> statement_unmatched .)
    Return          reduce using rule 14 (statement -> statement_unmatched .)
    LBrace          reduce using rule 14 (statement -> statement_unmatched .)
    Break           reduce using rule 14 (statement -> statement_unmatched .)
    For             reduce using rule 14 (statement -> statement_unmatched .)
    Do              reduce using rule 14 (statement -> statement_unmatched .)
    Continue        reduce using rule 14 (statement -> statement_unmatched .)
    Int             reduce using rule 14 (statement -> statement_unmatched .)
    Minus           reduce using rule 14 (statement -> statement_unmatched .)
    BitNot          reduce using rule 14 (statement -> statement_unmatched .)
    Not             reduce using rule 14 (statement -> statement_unmatched .)
    Identifier      reduce using rule 14 (statement -> statement_unmatched .)
    Integer         reduce using rule 14 (statement -> statement_unmatched .)
    LParen          reduce using rule 14 (statement -> statement_unmatched .)
    Semi            reduce using rule 14 (statement -> statement_unmatched .)


state 148

    (24) opt_expression -> expression .

    Semi            reduce using rule 24 (opt_expression -> expression .)
    RParen          reduce using rule 24 (opt_expression -> expression .)


state 149

    (15) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (16) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 163


state 150

    (18) statement_matched -> While . LParen expression RParen statement_matched
    (19) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 164


state 151

    (20) statement_matched -> Return . expression Semi
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 165
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 152

    (21) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 166


state 153

    (23) statement_matched -> Break . Semi

    Semi            shift and go to state 167


state 154

    (66) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (67) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched

    LParen          shift and go to state 168


state 155

    (70) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (71) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    statement_matched              shift and go to state 169
    expression                     shift and go to state 148
    statement_unmatched            shift and go to state 170
    opt_expression                 shift and go to state 152
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 156

    (72) statement_matched -> Continue . Semi

    Semi            shift and go to state 171


state 157

    (25) opt_expression -> empty .

    Semi            reduce using rule 25 (opt_expression -> empty .)
    RParen          reduce using rule 25 (opt_expression -> empty .)


state 158

    (83) expression_list -> expression_list Comma expression .

    RParen          reduce using rule 83 (expression_list -> expression_list Comma expression .)
    Comma           reduce using rule 83 (expression_list -> expression_list Comma expression .)


state 159

    (62) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 62 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 62 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 62 (conditional -> logical_or Question expression Colon conditional .)
    RBracket        reduce using rule 62 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 62 (conditional -> logical_or Question expression Colon conditional .)


state 160

    (26) declaration -> type Identifier .
    (27) declaration -> type Identifier . Assign expression
    (94) singledim_decl -> type Identifier . LBracket Integer RBracket

    Semi            reduce using rule 26 (declaration -> type Identifier .)
    Assign          shift and go to state 18
    LBracket        shift and go to state 19


state 161

    (22) statement_matched -> LBrace block . RBrace
    (9) block -> block . block_item
    (11) block_item -> . statement
    (12) block_item -> . declaration Semi
    (13) statement -> . statement_matched
    (14) statement -> . statement_unmatched
    (26) declaration -> . type Identifier
    (27) declaration -> . type Identifier Assign expression
    (92) declaration -> . multidim_decl
    (93) declaration -> . singledim_decl
    (100) declaration -> . multidim_decl Assign LBrace intlist RBrace
    (101) declaration -> . singledim_decl Assign LBrace intlist RBrace
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (6) type -> . Int
    (95) multidim_decl -> . singledim_decl LBracket Integer RBracket
    (96) multidim_decl -> . multidim_decl LBracket Integer RBracket
    (94) singledim_decl -> . type Identifier LBracket Integer RBracket
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    RBrace          shift and go to state 172
    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    block_item                     shift and go to state 143
    statement                      shift and go to state 144
    declaration                    shift and go to state 145
    statement_matched              shift and go to state 146
    statement_unmatched            shift and go to state 147
    type                           shift and go to state 140
    expression                     shift and go to state 148
    multidim_decl                  shift and go to state 5
    singledim_decl                 shift and go to state 6
    opt_expression                 shift and go to state 152
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 162

    (12) block_item -> declaration Semi .

    RBrace          reduce using rule 12 (block_item -> declaration Semi .)
    If              reduce using rule 12 (block_item -> declaration Semi .)
    While           reduce using rule 12 (block_item -> declaration Semi .)
    Return          reduce using rule 12 (block_item -> declaration Semi .)
    LBrace          reduce using rule 12 (block_item -> declaration Semi .)
    Break           reduce using rule 12 (block_item -> declaration Semi .)
    For             reduce using rule 12 (block_item -> declaration Semi .)
    Do              reduce using rule 12 (block_item -> declaration Semi .)
    Continue        reduce using rule 12 (block_item -> declaration Semi .)
    Int             reduce using rule 12 (block_item -> declaration Semi .)
    Minus           reduce using rule 12 (block_item -> declaration Semi .)
    BitNot          reduce using rule 12 (block_item -> declaration Semi .)
    Not             reduce using rule 12 (block_item -> declaration Semi .)
    Identifier      reduce using rule 12 (block_item -> declaration Semi .)
    Integer         reduce using rule 12 (block_item -> declaration Semi .)
    LParen          reduce using rule 12 (block_item -> declaration Semi .)
    Semi            reduce using rule 12 (block_item -> declaration Semi .)


state 163

    (15) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (16) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> If LParen . expression RParen statement
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 173
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 164

    (18) statement_matched -> While LParen . expression RParen statement_matched
    (19) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 174
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 165

    (20) statement_matched -> Return expression . Semi

    Semi            shift and go to state 175


state 166

    (21) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 21 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 21 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 21 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 21 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 21 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 21 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 21 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 21 (statement_matched -> opt_expression Semi .)


state 167

    (23) statement_matched -> Break Semi .

    RBrace          reduce using rule 23 (statement_matched -> Break Semi .)
    If              reduce using rule 23 (statement_matched -> Break Semi .)
    While           reduce using rule 23 (statement_matched -> Break Semi .)
    Return          reduce using rule 23 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 23 (statement_matched -> Break Semi .)
    Break           reduce using rule 23 (statement_matched -> Break Semi .)
    For             reduce using rule 23 (statement_matched -> Break Semi .)
    Do              reduce using rule 23 (statement_matched -> Break Semi .)
    Continue        reduce using rule 23 (statement_matched -> Break Semi .)
    Int             reduce using rule 23 (statement_matched -> Break Semi .)
    Minus           reduce using rule 23 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 23 (statement_matched -> Break Semi .)
    Not             reduce using rule 23 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 23 (statement_matched -> Break Semi .)
    Integer         reduce using rule 23 (statement_matched -> Break Semi .)
    LParen          reduce using rule 23 (statement_matched -> Break Semi .)
    Semi            reduce using rule 23 (statement_matched -> Break Semi .)
    Else            reduce using rule 23 (statement_matched -> Break Semi .)


state 168

    (66) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (67) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (26) declaration -> . type Identifier
    (27) declaration -> . type Identifier Assign expression
    (92) declaration -> . multidim_decl
    (93) declaration -> . singledim_decl
    (100) declaration -> . multidim_decl Assign LBrace intlist RBrace
    (101) declaration -> . singledim_decl Assign LBrace intlist RBrace
    (28) expression -> . assignment
    (1) empty -> .
    (6) type -> . Int
    (95) multidim_decl -> . singledim_decl LBracket Integer RBracket
    (96) multidim_decl -> . multidim_decl LBracket Integer RBracket
    (94) singledim_decl -> . type Identifier LBracket Integer RBracket
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 176
    declaration                    shift and go to state 177
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    type                           shift and go to state 140
    multidim_decl                  shift and go to state 5
    singledim_decl                 shift and go to state 6
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 169

    (70) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 178


state 170

    (71) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 179


state 171

    (72) statement_matched -> Continue Semi .

    RBrace          reduce using rule 72 (statement_matched -> Continue Semi .)
    If              reduce using rule 72 (statement_matched -> Continue Semi .)
    While           reduce using rule 72 (statement_matched -> Continue Semi .)
    Return          reduce using rule 72 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 72 (statement_matched -> Continue Semi .)
    Break           reduce using rule 72 (statement_matched -> Continue Semi .)
    For             reduce using rule 72 (statement_matched -> Continue Semi .)
    Do              reduce using rule 72 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 72 (statement_matched -> Continue Semi .)
    Int             reduce using rule 72 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 72 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 72 (statement_matched -> Continue Semi .)
    Not             reduce using rule 72 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 72 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 72 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 72 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 72 (statement_matched -> Continue Semi .)
    Else            reduce using rule 72 (statement_matched -> Continue Semi .)


state 172

    (22) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 22 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 22 (statement_matched -> LBrace block RBrace .)


state 173

    (15) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (16) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 180


state 174

    (18) statement_matched -> While LParen expression . RParen statement_matched
    (19) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 181


state 175

    (20) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 20 (statement_matched -> Return expression Semi .)
    If              reduce using rule 20 (statement_matched -> Return expression Semi .)
    While           reduce using rule 20 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 20 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 20 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 20 (statement_matched -> Return expression Semi .)
    For             reduce using rule 20 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 20 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 20 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 20 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 20 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 20 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 20 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 20 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 20 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 20 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 20 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 20 (statement_matched -> Return expression Semi .)


state 176

    (66) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched
    (67) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 182


state 177

    (68) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched
    (69) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 183


state 178

    (70) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 184


state 179

    (71) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 185


state 180

    (15) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (16) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (17) statement_unmatched -> If LParen expression RParen . statement
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (13) statement -> . statement_matched
    (14) statement -> . statement_unmatched
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 148
    statement_matched              shift and go to state 186
    statement_unmatched            shift and go to state 147
    statement                      shift and go to state 187
    opt_expression                 shift and go to state 152
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 181

    (18) statement_matched -> While LParen expression RParen . statement_matched
    (19) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 148
    statement_matched              shift and go to state 188
    statement_unmatched            shift and go to state 189
    opt_expression                 shift and go to state 152
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 182

    (66) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (67) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 190
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 183

    (68) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (69) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 191
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 184

    (70) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 192
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 185

    (71) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (28) expression -> . assignment
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 193
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 186

    (15) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (16) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (13) statement -> statement_matched .

    Else            shift and go to state 194
    RBrace          reduce using rule 13 (statement -> statement_matched .)
    If              reduce using rule 13 (statement -> statement_matched .)
    While           reduce using rule 13 (statement -> statement_matched .)
    Return          reduce using rule 13 (statement -> statement_matched .)
    LBrace          reduce using rule 13 (statement -> statement_matched .)
    Break           reduce using rule 13 (statement -> statement_matched .)
    For             reduce using rule 13 (statement -> statement_matched .)
    Do              reduce using rule 13 (statement -> statement_matched .)
    Continue        reduce using rule 13 (statement -> statement_matched .)
    Int             reduce using rule 13 (statement -> statement_matched .)
    Minus           reduce using rule 13 (statement -> statement_matched .)
    BitNot          reduce using rule 13 (statement -> statement_matched .)
    Not             reduce using rule 13 (statement -> statement_matched .)
    Identifier      reduce using rule 13 (statement -> statement_matched .)
    Integer         reduce using rule 13 (statement -> statement_matched .)
    LParen          reduce using rule 13 (statement -> statement_matched .)
    Semi            reduce using rule 13 (statement -> statement_matched .)


state 187

    (17) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 17 (statement_unmatched -> If LParen expression RParen statement .)


state 188

    (18) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 18 (statement_matched -> While LParen expression RParen statement_matched .)


state 189

    (19) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 19 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 190

    (66) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched
    (67) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 195


state 191

    (68) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched
    (69) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 196


state 192

    (70) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 197


state 193

    (71) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 198


state 194

    (15) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (16) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    expression                     shift and go to state 148
    statement_matched              shift and go to state 199
    statement_unmatched            shift and go to state 200
    opt_expression                 shift and go to state 152
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 195

    (66) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (67) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 201
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 196

    (68) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (69) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 202
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 197

    (70) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 203


state 198

    (71) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 204


state 199

    (15) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 15 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 200

    (16) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 201

    (66) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched
    (67) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 205


state 202

    (68) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched
    (69) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 206


state 203

    (70) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 70 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 204

    (71) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 71 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 205

    (66) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (67) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 152
    statement_matched              shift and go to state 207
    statement_unmatched            shift and go to state 208
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 206

    (68) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (69) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (15) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (18) statement_matched -> . While LParen expression RParen statement_matched
    (20) statement_matched -> . Return expression Semi
    (21) statement_matched -> . opt_expression Semi
    (22) statement_matched -> . LBrace block RBrace
    (23) statement_matched -> . Break Semi
    (66) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (68) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (70) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (72) statement_matched -> . Continue Semi
    (16) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (17) statement_unmatched -> . If LParen expression RParen statement
    (19) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (67) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (69) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (71) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (24) opt_expression -> . expression
    (25) opt_expression -> . empty
    (28) expression -> . assignment
    (1) empty -> .
    (29) assignment -> . conditional
    (45) assignment -> . unary Assign expression
    (30) conditional -> . logical_or
    (62) conditional -> . logical_or Question expression Colon conditional
    (40) unary -> . postfix
    (42) unary -> . Minus unary
    (43) unary -> . BitNot unary
    (44) unary -> . Not unary
    (31) logical_or -> . logical_and
    (46) logical_or -> . logical_or Or logical_and
    (41) postfix -> . primary
    (86) postfix -> . Identifier LParen expression_list RParen
    (87) postfix -> . multidim_arr
    (88) postfix -> . singledim_arr
    (32) logical_and -> . bit_or
    (47) logical_and -> . logical_and And bit_or
    (63) primary -> . Integer
    (64) primary -> . Identifier
    (65) primary -> . LParen expression RParen
    (90) multidim_arr -> . singledim_arr LBracket expression RBracket
    (91) multidim_arr -> . multidim_arr LBracket expression RBracket
    (89) singledim_arr -> . Identifier LBracket expression RBracket
    (33) bit_or -> . xor
    (48) bit_or -> . bit_or BitOr xor
    (34) xor -> . bit_and
    (49) xor -> . xor Xor bit_and
    (35) bit_and -> . equality
    (50) bit_and -> . bit_and BitAnd equality
    (36) equality -> . relational
    (51) equality -> . equality NotEqual relational
    (52) equality -> . equality Equal relational
    (37) relational -> . additive
    (53) relational -> . relational Less additive
    (54) relational -> . relational Greater additive
    (55) relational -> . relational LessEqual additive
    (56) relational -> . relational GreaterEqual additive
    (38) additive -> . multiplicative
    (57) additive -> . additive Plus multiplicative
    (58) additive -> . additive Minus multiplicative
    (39) multiplicative -> . unary
    (59) multiplicative -> . multiplicative Mul unary
    (60) multiplicative -> . multiplicative Div unary
    (61) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 149
    While           shift and go to state 150
    Return          shift and go to state 151
    LBrace          shift and go to state 141
    Break           shift and go to state 153
    For             shift and go to state 154
    Do              shift and go to state 155
    Continue        shift and go to state 156
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 38
    BitNot          shift and go to state 39
    Not             shift and go to state 40
    Identifier      shift and go to state 31
    Integer         shift and go to state 47
    LParen          shift and go to state 43

    opt_expression                 shift and go to state 152
    statement_matched              shift and go to state 209
    statement_unmatched            shift and go to state 210
    expression                     shift and go to state 148
    empty                          shift and go to state 157
    assignment                     shift and go to state 33
    conditional                    shift and go to state 34
    unary                          shift and go to state 35
    logical_or                     shift and go to state 36
    postfix                        shift and go to state 37
    logical_and                    shift and go to state 41
    primary                        shift and go to state 42
    multidim_arr                   shift and go to state 44
    singledim_arr                  shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 48
    bit_and                        shift and go to state 49
    equality                       shift and go to state 50
    relational                     shift and go to state 51
    additive                       shift and go to state 52
    multiplicative                 shift and go to state 53

state 207

    (66) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 66 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)


state 208

    (67) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 67 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 209

    (68) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 68 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)


state 210

    (69) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 69 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)

